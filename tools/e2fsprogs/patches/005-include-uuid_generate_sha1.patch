From 13a53c84801d57f1d76656f7913628a7b526c335 Mon Sep 17 00:00:00 2001
From: Torste Aikio <zokier@gmail.com>
Date: Sun, 25 Feb 2024 22:18:18 +0200
Subject: [PATCH] include uuid_generate_sha1

---
 lib/uuid/Makefile.in |   4 +
 lib/uuid/gen_uuid.c  |  27 +++++
 lib/uuid/sha1.c      | 263 +++++++++++++++++++++++++++++++++++++++++++
 lib/uuid/sha1.h      |  31 +++++
 lib/uuid/uuid.h.in   |   2 +
 5 files changed, 327 insertions(+)
 create mode 100644 lib/uuid/sha1.c
 create mode 100644 lib/uuid/sha1.h

diff --git a/lib/uuid/Makefile.in b/lib/uuid/Makefile.in
index 5f697792..dd9231b9 100644
--- a/lib/uuid/Makefile.in
+++ b/lib/uuid/Makefile.in
@@ -24,6 +24,7 @@ OBJS=		clear.o \
 		isnull.o \
 		pack.o \
 		parse.o \
+		sha1.o \
 		unpack.o \
 		unparse.o \
 		uuid_time.o
@@ -35,6 +36,7 @@ SRCS=		$(srcdir)/clear.c \
 		$(srcdir)/isnull.c \
 		$(srcdir)/pack.c \
 		$(srcdir)/parse.c \
+		$(srcdir)/sha1.c \
 		$(srcdir)/unpack.c \
 		$(srcdir)/unparse.c \
 		$(srcdir)/uuid_time.c
@@ -206,6 +208,8 @@ isnull.o: $(srcdir)/isnull.c $(top_builddir)/lib/config.h \
  $(top_builddir)/lib/dirpaths.h $(srcdir)/uuidP.h
 pack.o: $(srcdir)/pack.c $(top_builddir)/lib/config.h \
  $(top_builddir)/lib/dirpaths.h $(srcdir)/uuidP.h
+sha1.o: $(srcdir)/sha1.c $(top_builddir)/lib/config.h \
+ $(top_builddir)/lib/dirpaths.h $(srcdir)/uuidP.h $(srcdir)/sha1.h
 parse.o: $(srcdir)/parse.c $(top_builddir)/lib/config.h \
  $(top_builddir)/lib/dirpaths.h $(srcdir)/uuidP.h
 unpack.o: $(srcdir)/unpack.c $(top_builddir)/lib/config.h \
diff --git a/lib/uuid/gen_uuid.c b/lib/uuid/gen_uuid.c
index 2f028867..c208c045 100644
--- a/lib/uuid/gen_uuid.c
+++ b/lib/uuid/gen_uuid.c
@@ -41,6 +41,7 @@
 
 #include "config.h"
 
+#include <assert.h>
 #include <stdio.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -95,6 +96,7 @@
 
 #include "uuidP.h"
 #include "uuidd.h"
+#include "sha1.h"
 
 #ifdef HAVE_SRANDOM
 #define srand(x) 	srandom(x)
@@ -666,6 +668,31 @@ void uuid_generate_random(uuid_t out)
 	uuid__generate_random(out, &num);
 }
 
+/*
+ * Generate a SHA1 hashed (predictable) UUID based on a well-known UUID
+ * providing the namespace and an arbitrary binary string.
+ */
+void uuid_generate_sha1(uuid_t out, const uuid_t ns, const char *name, size_t len)
+{
+	UL_SHA1_CTX ctx;
+	char hash[UL_SHA1LENGTH];
+	uuid_t buf;
+	struct uuid uu;
+
+	ul_SHA1Init(&ctx);
+	ul_SHA1Update(&ctx, ns, sizeof(uuid_t));
+	ul_SHA1Update(&ctx, (const unsigned char *)name, len);
+	ul_SHA1Final((unsigned char *)hash, &ctx);
+
+	assert(sizeof(buf) <= sizeof(hash));
+
+	memcpy(buf, hash, sizeof(buf));
+	uuid_unpack(buf, &uu);
+
+	uu.clock_seq = (uu.clock_seq & 0x3FFF) | 0x8000;
+	uu.time_hi_and_version = (uu.time_hi_and_version & 0x0FFF) | 0x5000;
+	uuid_pack(&uu, out);
+}
 
 /*
  * This is the generic front-end to uuid_generate_random and
diff --git a/lib/uuid/sha1.c b/lib/uuid/sha1.c
new file mode 100644
index 00000000..32ef5b9c
--- /dev/null
+++ b/lib/uuid/sha1.c
@@ -0,0 +1,263 @@
+/*
+ * No copyright is claimed.  This code is in the public domain; do with
+ * it what you wish.
+ *
+ * SHA-1 in C by Steve Reid <steve@edmweb.com>
+ * 100% Public Domain
+ *
+ * Test Vectors (from FIPS PUB 180-1)
+ * 1) "abc": A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
+ * 2) "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq":  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
+ * 3) A million repetitions of "a":  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
+ */
+
+#define UL_SHA1HANDSOFF
+
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "sha1.h"
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+# define blk0(i) block->l[i]
+#else
+# define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
+    |(rol(block->l[i],8)&0x00FF00FF))
+#endif
+
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+    ^block->l[(i+2)&15]^block->l[i&15],1))
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+
+void ul_SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
+{
+	uint32_t a, b, c, d, e;
+
+	typedef union {
+		unsigned char c[64];
+		uint32_t l[16];
+	} CHAR64LONG16;
+
+#ifdef UL_SHA1HANDSOFF
+	CHAR64LONG16 block[1];	/* use array to appear as a pointer */
+
+	memcpy(block, buffer, 64);
+#else
+	/* The following had better never be used because it causes the
+	 * pointer-to-const buffer to be cast into a pointer to non-const.
+	 * And the result is written through.  I threw a "const" in, hoping
+	 * this will cause a diagnostic.
+	 */
+	CHAR64LONG16 *block = (const CHAR64LONG16 *)buffer;
+#endif
+	/* Copy context->state[] to working vars */
+	a = state[0];
+	b = state[1];
+	c = state[2];
+	d = state[3];
+	e = state[4];
+	/* 4 rounds of 20 operations each. Loop unrolled. */
+	R0(a, b, c, d, e, 0);
+	R0(e, a, b, c, d, 1);
+	R0(d, e, a, b, c, 2);
+	R0(c, d, e, a, b, 3);
+	R0(b, c, d, e, a, 4);
+	R0(a, b, c, d, e, 5);
+	R0(e, a, b, c, d, 6);
+	R0(d, e, a, b, c, 7);
+	R0(c, d, e, a, b, 8);
+	R0(b, c, d, e, a, 9);
+	R0(a, b, c, d, e, 10);
+	R0(e, a, b, c, d, 11);
+	R0(d, e, a, b, c, 12);
+	R0(c, d, e, a, b, 13);
+	R0(b, c, d, e, a, 14);
+	R0(a, b, c, d, e, 15);
+	R1(e, a, b, c, d, 16);
+	R1(d, e, a, b, c, 17);
+	R1(c, d, e, a, b, 18);
+	R1(b, c, d, e, a, 19);
+	R2(a, b, c, d, e, 20);
+	R2(e, a, b, c, d, 21);
+	R2(d, e, a, b, c, 22);
+	R2(c, d, e, a, b, 23);
+	R2(b, c, d, e, a, 24);
+	R2(a, b, c, d, e, 25);
+	R2(e, a, b, c, d, 26);
+	R2(d, e, a, b, c, 27);
+	R2(c, d, e, a, b, 28);
+	R2(b, c, d, e, a, 29);
+	R2(a, b, c, d, e, 30);
+	R2(e, a, b, c, d, 31);
+	R2(d, e, a, b, c, 32);
+	R2(c, d, e, a, b, 33);
+	R2(b, c, d, e, a, 34);
+	R2(a, b, c, d, e, 35);
+	R2(e, a, b, c, d, 36);
+	R2(d, e, a, b, c, 37);
+	R2(c, d, e, a, b, 38);
+	R2(b, c, d, e, a, 39);
+	R3(a, b, c, d, e, 40);
+	R3(e, a, b, c, d, 41);
+	R3(d, e, a, b, c, 42);
+	R3(c, d, e, a, b, 43);
+	R3(b, c, d, e, a, 44);
+	R3(a, b, c, d, e, 45);
+	R3(e, a, b, c, d, 46);
+	R3(d, e, a, b, c, 47);
+	R3(c, d, e, a, b, 48);
+	R3(b, c, d, e, a, 49);
+	R3(a, b, c, d, e, 50);
+	R3(e, a, b, c, d, 51);
+	R3(d, e, a, b, c, 52);
+	R3(c, d, e, a, b, 53);
+	R3(b, c, d, e, a, 54);
+	R3(a, b, c, d, e, 55);
+	R3(e, a, b, c, d, 56);
+	R3(d, e, a, b, c, 57);
+	R3(c, d, e, a, b, 58);
+	R3(b, c, d, e, a, 59);
+	R4(a, b, c, d, e, 60);
+	R4(e, a, b, c, d, 61);
+	R4(d, e, a, b, c, 62);
+	R4(c, d, e, a, b, 63);
+	R4(b, c, d, e, a, 64);
+	R4(a, b, c, d, e, 65);
+	R4(e, a, b, c, d, 66);
+	R4(d, e, a, b, c, 67);
+	R4(c, d, e, a, b, 68);
+	R4(b, c, d, e, a, 69);
+	R4(a, b, c, d, e, 70);
+	R4(e, a, b, c, d, 71);
+	R4(d, e, a, b, c, 72);
+	R4(c, d, e, a, b, 73);
+	R4(b, c, d, e, a, 74);
+	R4(a, b, c, d, e, 75);
+	R4(e, a, b, c, d, 76);
+	R4(d, e, a, b, c, 77);
+	R4(c, d, e, a, b, 78);
+	R4(b, c, d, e, a, 79);
+	/* Add the working vars back into context.state[] */
+	state[0] += a;
+	state[1] += b;
+	state[2] += c;
+	state[3] += d;
+	state[4] += e;
+	/* Wipe variables */
+	explicit_bzero(&a, sizeof(a));
+	explicit_bzero(&b, sizeof(b));
+	explicit_bzero(&c, sizeof(c));
+	explicit_bzero(&d, sizeof(d));
+	explicit_bzero(&e, sizeof(e));
+#ifdef UL_SHA1HANDSOFF
+	memset(block, '\0', sizeof(block));
+#endif
+}
+
+/* SHA1Init - Initialize new context */
+
+void ul_SHA1Init(UL_SHA1_CTX *context)
+{
+	/* SHA1 initialization constants */
+	context->state[0] = 0x67452301;
+	context->state[1] = 0xEFCDAB89;
+	context->state[2] = 0x98BADCFE;
+	context->state[3] = 0x10325476;
+	context->state[4] = 0xC3D2E1F0;
+	context->count[0] = context->count[1] = 0;
+}
+
+/* Run your data through this. */
+
+void ul_SHA1Update(UL_SHA1_CTX *context, const unsigned char *data, uint32_t len)
+{
+	uint32_t i;
+
+	uint32_t j;
+
+	j = context->count[0];
+	if ((context->count[0] += len << 3) < j)
+		context->count[1]++;
+	context->count[1] += (len >> 29);
+	j = (j >> 3) & 63;
+	if ((j + len) > 63) {
+		memcpy(&context->buffer[j], data, (i = 64 - j));
+		ul_SHA1Transform(context->state, context->buffer);
+		for (; i + 63 < len; i += 64) {
+			ul_SHA1Transform(context->state, &data[i]);
+		}
+		j = 0;
+	} else
+		i = 0;
+	memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+/* Add padding and return the message digest. */
+
+void ul_SHA1Final(unsigned char digest[20], UL_SHA1_CTX *context)
+{
+	unsigned i;
+
+	unsigned char finalcount[8];
+
+	unsigned char c;
+
+#if 0				/* untested "improvement" by DHR */
+	/* Convert context->count to a sequence of bytes
+	 * in finalcount.  Second element first, but
+	 * big-endian order within element.
+	 * But we do it all backwards.
+	 */
+	unsigned char *fcp = &finalcount[8];
+
+	for (i = 0; i < 2; i++) {
+		uint32_t t = context->count[i];
+
+		int j;
+
+		for (j = 0; j < 4; t >>= 8, j++)
+			*--fcp = (unsigned char)t}
+#else
+	for (i = 0; i < 8; i++) {
+		finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);	/* Endian independent */
+	}
+#endif
+	c = 0200;
+	ul_SHA1Update(context, &c, 1);
+	while ((context->count[0] & 504) != 448) {
+		c = 0000;
+		ul_SHA1Update(context, &c, 1);
+	}
+	ul_SHA1Update(context, finalcount, 8);	/* Should cause a SHA1Transform() */
+	for (i = 0; i < 20; i++) {
+		digest[i] = (unsigned char)
+		    ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
+	}
+	/* Wipe variables */
+	memset(context, '\0', sizeof(*context));
+	memset(&finalcount, '\0', sizeof(finalcount));
+}
+
+void ul_SHA1(char *hash_out, const char *str, unsigned len)
+{
+	UL_SHA1_CTX ctx;
+	unsigned int ii;
+
+	ul_SHA1Init(&ctx);
+	for (ii = 0; ii < len; ii += 1)
+		ul_SHA1Update(&ctx, (const unsigned char *)str + ii, 1);
+	ul_SHA1Final((unsigned char *)hash_out, &ctx);
+	hash_out[20] = '\0';
+}
diff --git a/lib/uuid/sha1.h b/lib/uuid/sha1.h
new file mode 100644
index 00000000..8ec74c9b
--- /dev/null
+++ b/lib/uuid/sha1.h
@@ -0,0 +1,31 @@
+/*
+ * No copyright is claimed.  This code is in the public domain; do with
+ * it what you wish.
+ */
+#ifndef UTIL_LINUX_SHA1_H
+#define UTIL_LINUX_SHA1_H
+
+/*
+   SHA-1 in C
+   By Steve Reid <steve@edmweb.com>
+   100% Public Domain
+ */
+
+#include "stdint.h"
+
+#define UL_SHA1LENGTH		20
+
+typedef struct
+{
+    uint32_t	state[5];
+    uint32_t	count[2];
+    unsigned	char buffer[64];
+} UL_SHA1_CTX;
+
+void ul_SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);
+void ul_SHA1Init(UL_SHA1_CTX *context);
+void ul_SHA1Update(UL_SHA1_CTX *context, const unsigned char *data, uint32_t len);
+void ul_SHA1Final(unsigned char digest[UL_SHA1LENGTH], UL_SHA1_CTX *context);
+void ul_SHA1(char *hash_out, const char *str, unsigned len);
+
+#endif /* UTIL_LINUX_SHA1_H */
diff --git a/lib/uuid/uuid.h.in b/lib/uuid/uuid.h.in
index ca846da0..c77d325e 100644
--- a/lib/uuid/uuid.h.in
+++ b/lib/uuid/uuid.h.in
@@ -52,6 +52,7 @@ typedef unsigned char uuid_t[16];
 /* UUID Type definitions */
 #define UUID_TYPE_DCE_TIME   1
 #define UUID_TYPE_DCE_RANDOM 4
+#define UUID_TYPE_DCE_SHA1   5
 
 /* Allow UUID constants to be defined */
 #ifdef __GNUC__
@@ -79,6 +80,7 @@ void uuid_copy(uuid_t dst, const uuid_t src);
 void uuid_generate(uuid_t out);
 void uuid_generate_random(uuid_t out);
 void uuid_generate_time(uuid_t out);
+void uuid_generate_sha1(uuid_t out, const uuid_t ns, const char *name, size_t len);
 
 /* isnull.c */
 int uuid_is_null(const uuid_t uu);
-- 
2.43.2

